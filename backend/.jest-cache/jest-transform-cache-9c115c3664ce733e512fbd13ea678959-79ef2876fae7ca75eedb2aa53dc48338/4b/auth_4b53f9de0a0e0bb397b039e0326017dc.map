{"file":"D:\\dev\\contabil\\contabil-site\\backend\\src\\utils\\auth.ts","mappings":";;;;;;AAAA,oDAA4B;AAC5B,gEAA+B;AAC/B,6CAA0C;AAE1C;;;;GAIG;AACI,MAAM,YAAY,GAAG,KAAK,EAAE,QAAgB,EAAmB,EAAE;IACtE,MAAM,UAAU,GAAG,EAAE,CAAC;IACtB,OAAO,gBAAM,CAAC,IAAI,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC;AAC3C,CAAC,CAAC;AAHW,QAAA,YAAY,gBAGvB;AAEF;;;;;GAKG;AACI,MAAM,eAAe,GAAG,KAAK,EAAE,QAAgB,EAAE,IAAY,EAAoB,EAAE;IACxF,OAAO,gBAAM,CAAC,OAAO,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;AACxC,CAAC,CAAC;AAFW,QAAA,eAAe,mBAE1B;AAEF;;;;;GAKG;AACI,MAAM,aAAa,GAAG,CAAC,OAAe,EAAE,YAAoB,IAAI,EAAU,EAAE;IACjF,OAAO,sBAAG,CAAC,IAAI,CAAC,OAAO,EAAE,eAAM,CAAC,GAAG,CAAC,MAAM,EAAE,EAAE,SAAS,EAAqB,CAAC,CAAC;AAChF,CAAC,CAAC;AAFW,QAAA,aAAa,iBAExB;AAEF;;;;GAIG;AACI,MAAM,WAAW,GAAG,CAAC,KAAa,EAAO,EAAE;IAChD,OAAO,sBAAG,CAAC,MAAM,CAAC,KAAK,EAAE,eAAM,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;AAC9C,CAAC,CAAC;AAFW,QAAA,WAAW,eAEtB;AAEF;;;;GAIG;AACI,MAAM,oBAAoB,GAAG,CAAC,OAAe,EAAU,EAAE;IAC9D,OAAO,sBAAG,CAAC,IAAI,CAAC,OAAO,EAAE,eAAM,CAAC,GAAG,CAAC,aAAa,EAAE,EAAE,SAAS,EAAE,IAAI,EAAqB,CAAC,CAAC;AAC7F,CAAC,CAAC;AAFW,QAAA,oBAAoB,wBAE/B;AAEF;;;;GAIG;AACI,MAAM,kBAAkB,GAAG,CAAC,KAAa,EAAO,EAAE;IACvD,OAAO,sBAAG,CAAC,MAAM,CAAC,KAAK,EAAE,eAAM,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC;AACrD,CAAC,CAAC;AAFW,QAAA,kBAAkB,sBAE7B;AAEF;;;;GAIG;AACI,MAAM,wBAAwB,GAAG,CAAC,QAAgB,EAAW,EAAE;IACpE,wGAAwG;IACxG,MAAM,aAAa,GAAG,sEAAsE,CAAC;IAC7F,OAAO,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;AACtC,CAAC,CAAC;AAJW,QAAA,wBAAwB,4BAInC;AAEF;;;;GAIG;AACI,MAAM,aAAa,GAAG,CAAC,KAAa,EAAW,EAAE;IACtD,MAAM,UAAU,GAAG,4BAA4B,CAAC;IAChD,OAAO,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AAChC,CAAC,CAAC;AAHW,QAAA,aAAa,iBAGxB","names":[],"sources":["D:\\dev\\contabil\\contabil-site\\backend\\src\\utils\\auth.ts"],"sourcesContent":["import bcrypt from 'bcrypt';\r\nimport jwt from 'jsonwebtoken';\r\nimport { config } from '../config/config';\r\n\r\n/**\r\n * Gera um hash da senha usando bcrypt\r\n * @param password - Senha em texto plano\r\n * @returns Promise com o hash da senha\r\n */\r\nexport const hashPassword = async (password: string): Promise<string> => {\r\n  const saltRounds = 12;\r\n  return bcrypt.hash(password, saltRounds);\r\n};\r\n\r\n/**\r\n * Compara uma senha em texto plano com um hash\r\n * @param password - Senha em texto plano\r\n * @param hash - Hash da senha\r\n * @returns Promise com resultado da comparação\r\n */\r\nexport const comparePassword = async (password: string, hash: string): Promise<boolean> => {\r\n  return bcrypt.compare(password, hash);\r\n};\r\n\r\n/**\r\n * Gera um token JWT\r\n * @param payload - Dados a serem incluídos no token\r\n * @param expiresIn - Tempo de expiração do token (padrão: 1h)\r\n * @returns Token JWT\r\n */\r\nexport const generateToken = (payload: object, expiresIn: string = '1h'): string => {\r\n  return jwt.sign(payload, config.jwt.secret, { expiresIn } as jwt.SignOptions);\r\n};\r\n\r\n/**\r\n * Verifica e decodifica um token JWT\r\n * @param token - Token JWT a ser verificado\r\n * @returns Payload decodificado do token\r\n */\r\nexport const verifyToken = (token: string): any => {\r\n  return jwt.verify(token, config.jwt.secret);\r\n};\r\n\r\n/**\r\n * Gera um refresh token JWT\r\n * @param payload - Dados a serem incluídos no token\r\n * @returns Refresh token JWT\r\n */\r\nexport const generateRefreshToken = (payload: object): string => {\r\n  return jwt.sign(payload, config.jwt.refreshSecret, { expiresIn: '7d' } as jwt.SignOptions);\r\n};\r\n\r\n/**\r\n * Verifica um refresh token JWT\r\n * @param token - Refresh token a ser verificado\r\n * @returns Payload decodificado do refresh token\r\n */\r\nexport const verifyRefreshToken = (token: string): any => {\r\n  return jwt.verify(token, config.jwt.refreshSecret);\r\n};\r\n\r\n/**\r\n * Valida a força de uma senha\r\n * @param password - Senha a ser validada\r\n * @returns true se a senha for forte, false caso contrário\r\n */\r\nexport const validatePasswordStrength = (password: string): boolean => {\r\n  // Mínimo 8 caracteres, pelo menos uma letra maiúscula, uma minúscula, um número e um caractere especial\r\n  const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$/;\r\n  return passwordRegex.test(password);\r\n};\r\n\r\n/**\r\n * Valida formato de email\r\n * @param email - Email a ser validado\r\n * @returns true se o email for válido, false caso contrário\r\n */\r\nexport const validateEmail = (email: string): boolean => {\r\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n  return emailRegex.test(email);\r\n};"],"version":3}